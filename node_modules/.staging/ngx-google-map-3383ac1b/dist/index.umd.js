/**
 * ngx-google-map - ngx-google-map is a angular 4 and above component for angular apps.
 * @version v1.0.0
 * @author Manish Kumar
 * @link https://github.com/manishjanky/ngx-google-map#readme
 * @license MIT
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("@angular/core"), require("@angular/common"));
	else if(typeof define === 'function' && define.amd)
		define(["@angular/core", "@angular/common"], factory);
	else if(typeof exports === 'object')
		exports["ticktock"] = factory(require("@angular/core"), require("@angular/common"));
	else
		root["ticktock"] = factory(root["ng"]["core"], root["ng"]["common"]);
})(typeof self !== 'undefined' ? self : this, function(__WEBPACK_EXTERNAL_MODULE_1__, __WEBPACK_EXTERNAL_MODULE_10__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 2);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(1);
var NgxGoogleMapComponent = /** @class */ (function () {
    function NgxGoogleMapComponent() {
        this.mapType = 'ROADMAP';
        this.multiplePlaces = false;
        this.mapClick = new core_1.EventEmitter();
        this.markerClick = new core_1.EventEmitter();
        this.locationSelected = new core_1.EventEmitter();
        this.mapOptions = {
            center: new google.maps.LatLng(51.5073391, -0.1284288),
            zoom: 16,
            mapTypeControl: true
        };
        this.markers = [];
        this.infoWindow = null;
        this.selectedLocations = [];
        console.log('Initializing Map');
    }
    NgxGoogleMapComponent.prototype.ngOnInit = function () {
        this.mapOptions.mapTypeId = google.maps.MapTypeId[this.mapType];
        this.mapOptions.mapTypeControlOptions = {
            style: google.maps.MapTypeControlStyle.HORIZONTAL_BAR,
            position: google.maps.ControlPosition.LEFT_BOTTOM
        };
        this.mapInstance = new google.maps.Map(this.mapElement.nativeElement, this.mapOptions);
        this.initMap();
    };
    NgxGoogleMapComponent.prototype.initMap = function () {
        this.addSearchBox();
        this.addDoneButton();
        this.initMapEvents();
    };
    NgxGoogleMapComponent.prototype.initMapEvents = function () {
        var _this = this;
        google.maps.event.addListener(this.mapInstance, 'click', function (event) {
            _this.placeMarkerAndPanTo(event.latLng);
            _this.mapClick.emit(event);
            console.log(event);
        });
    };
    NgxGoogleMapComponent.prototype.addDoneButton = function () {
        var _this = this;
        var controlUI = this.doneButton.nativeElement;
        controlUI.index = 1;
        controlUI.addEventListener('click', function (event) {
            _this.locationSelected.emit({ event: event, locations: _this.selectedLocations });
            console.log(_this.selectedLocations);
        });
        this.mapInstance.controls[google.maps.ControlPosition.BOTTOM_CENTER].push(controlUI);
    };
    NgxGoogleMapComponent.prototype.placeMarkerAndPanTo = function (latLang) {
        if (!this.multiplePlaces) {
            this.clearMarkers();
        }
        var marker = new google.maps.Marker({
            position: latLang,
            map: this.mapInstance,
            draggable: true
        });
        this.markers.push(marker);
        this.getMarketLocation(marker);
        this.addClickToMarker(marker);
        this.addDragToMarker(marker);
        this.mapInstance.panTo(latLang);
    };
    NgxGoogleMapComponent.prototype.addDragToMarker = function (marker) {
        var _this = this;
        google.maps.event.addListener(marker, 'dragend', function (event) {
            _this.getMarketLocation(marker);
        });
    };
    NgxGoogleMapComponent.prototype.getMarketLocation = function (marker) {
        var currentLocation = marker.getPosition();
        var pos = {};
        // Add lat and lng values to a field that we can save.
        pos.latitude = currentLocation.lat(); // latitude
        pos.longitude = currentLocation.lng();
        if (this.multiplePlaces) {
            this.selectedLocations.push(pos);
            return;
        }
        this.selectedLocations[0] = pos;
    };
    NgxGoogleMapComponent.prototype.addClickToMarker = function (marker) {
        var _this = this;
        var geocoder = new google.maps.Geocoder();
        google.maps.event.addListener(marker, 'click', function (event) {
            if (_this.infoWindow) {
                _this.infoWindow.close();
            }
            _this.infoWindow = new google.maps.InfoWindow();
            if (event) {
                _this.getFromattedAddress(geocoder, event.latLng.toUrlValue(), _this.infoWindow);
            }
            _this.infoWindow.open(_this.mapInstance, marker);
            _this.markerClick.emit(event);
            console.log(event);
        });
    };
    NgxGoogleMapComponent.prototype.addSearchBox = function () {
        this.mapSearchBox = new google.maps.places.SearchBox(this.searchInput.nativeElement);
        this.mapInstance.controls[google.maps.ControlPosition.TOP_LEFT]
            .push(this.searchInput.nativeElement);
        this.addSearchEvent();
    };
    NgxGoogleMapComponent.prototype.getFromattedAddress = function (geocoder, latlang, infowindow) {
        var latlngStr = latlang.split(',');
        var latlng = { lat: parseFloat(latlngStr[0]), lng: parseFloat(latlngStr[1]) };
        geocoder.geocode({ location: latlng }, function (results, status) {
            if (status === 'OK') {
                if (results[0]) {
                    infowindow.setContent(results[0].formatted_address);
                }
            }
        });
    };
    NgxGoogleMapComponent.prototype.addSearchEvent = function () {
        var _this = this;
        this.mapSearchBox.addListener('places_changed', function () {
            _this.searchPlace();
        });
    };
    NgxGoogleMapComponent.prototype.clearMarkers = function () {
        var _this = this;
        this.markers.forEach(function (marker, index) {
            marker.setMap(null);
            _this.markers.splice(index, 1);
        });
    };
    NgxGoogleMapComponent.prototype.searchPlace = function () {
        var _this = this;
        var places = this.mapSearchBox.getPlaces();
        if (places.length === 0) {
            return;
        }
        this.clearMarkers();
        var bounds = new google.maps.LatLngBounds();
        places.forEach(function (place) {
            if (!place.geometry) {
                console.log('Returned place contains no geometry');
                return;
            }
            var icon = {
                url: place.icon,
                size: new google.maps.Size(71, 71),
                origin: new google.maps.Point(0, 0),
                anchor: new google.maps.Point(17, 34),
                scaledSize: new google.maps.Size(25, 25)
            };
            _this.placeMarkerAndPanTo(place.geometry.location);
            if (place.geometry.viewport) {
                // Only geocodes have viewport.
                bounds.union(place.geometry.viewport);
            }
            else {
                bounds.extend(place.geometry.location);
            }
        });
        this.mapInstance.fitBounds(bounds);
    };
    __decorate([
        core_1.Input(),
        __metadata("design:type", String)
    ], NgxGoogleMapComponent.prototype, "mapType", void 0);
    __decorate([
        core_1.Input(),
        __metadata("design:type", Boolean)
    ], NgxGoogleMapComponent.prototype, "multiplePlaces", void 0);
    __decorate([
        core_1.Output(),
        __metadata("design:type", core_1.EventEmitter)
    ], NgxGoogleMapComponent.prototype, "mapClick", void 0);
    __decorate([
        core_1.Output(),
        __metadata("design:type", core_1.EventEmitter)
    ], NgxGoogleMapComponent.prototype, "markerClick", void 0);
    __decorate([
        core_1.Output(),
        __metadata("design:type", core_1.EventEmitter)
    ], NgxGoogleMapComponent.prototype, "locationSelected", void 0);
    __decorate([
        core_1.ViewChild('map'),
        __metadata("design:type", core_1.ElementRef)
    ], NgxGoogleMapComponent.prototype, "mapElement", void 0);
    __decorate([
        core_1.ViewChild('searchBox'),
        __metadata("design:type", core_1.ElementRef)
    ], NgxGoogleMapComponent.prototype, "searchInput", void 0);
    __decorate([
        core_1.ViewChild('doneBtn'),
        __metadata("design:type", core_1.ElementRef)
    ], NgxGoogleMapComponent.prototype, "doneButton", void 0);
    NgxGoogleMapComponent = __decorate([
        core_1.Component({
            selector: 'ngx-google-map',
            template: __webpack_require__(5),
            styles: [__webpack_require__(6)]
        }),
        __metadata("design:paramtypes", [])
    ], NgxGoogleMapComponent);
    return NgxGoogleMapComponent;
}());
exports.NgxGoogleMapComponent = NgxGoogleMapComponent;


/***/ }),
/* 1 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_1__;

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var components_1 = __webpack_require__(3);
exports.NgxGoogleMapComponent = components_1.NgxGoogleMapComponent;
var ngx_google_map_module_1 = __webpack_require__(9);
exports.NgxGoogleMapModule = ngx_google_map_module_1.NgxGoogleMapModule;


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(4));


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(0));


/***/ }),
/* 5 */
/***/ (function(module, exports) {

module.exports = "<div class=\"maps-wrapper\">\r\n  <div class=\"search-field\">\r\n    <input id='pac-input' class='search-box' type=\"text\" #searchBox>\r\n  </div>\r\n  <button class=\"done-button\" #doneBtn>Done</button>\r\n  <div #map class=\"map\">\r\n  </div>\r\n</div>"

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {


        var result = __webpack_require__(7);

        if (typeof result === "string") {
            module.exports = result;
        } else {
            module.exports = result.toString();
        }
    

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(8)(false);
// imports


// module
exports.push([module.i, ".maps-wrapper {\n  padding: 10px;\n  max-width: 100%; }\n  .maps-wrapper .map {\n    min-width: 300px;\n    min-height: 300px; }\n\n.search-box {\n  box-sizing: border-box;\n  display: block;\n  width: 75%;\n  min-width: 200px !important;\n  padding: 0.1em 0.5em;\n  margin-top: 10px;\n  font-size: 1rem;\n  line-height: 1.5;\n  color: #495057;\n  background-color: #fff;\n  background-clip: padding-box;\n  border: 1px solid #ced4da;\n  border-radius: .25rem;\n  transition: border-color .15s ease-in-out, box-shadow .15s ease-in-out; }\n  .search-box:focus {\n    color: #495057;\n    background-color: #fff;\n    border-color: #80bdff;\n    outline: 0;\n    box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25); }\n\n.done-button {\n  direction: ltr;\n  overflow: hidden;\n  text-align: center;\n  position: relative;\n  color: black;\n  font-family: Roboto, Arial, sans-serif;\n  user-select: none;\n  font-size: 11px;\n  background-color: white;\n  padding: 9px;\n  border: none;\n  margin-bottom: 38px;\n  background-clip: padding-box;\n  box-shadow: rgba(0, 0, 0, 0.3) 0px 1px 4px -1px;\n  min-width: 21px;\n  font-weight: 500; }\n  .done-button:hover {\n    background: lightgray; }\n", ""]);

// exports


/***/ }),
/* 8 */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function(useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if(item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function(modules, mediaQuery) {
		if(typeof modules === "string")
			modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for(var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if(typeof id === "number")
				alreadyImportedModules[id] = true;
		}
		for(i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if(mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if(mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var ngx_google_maps_component_1 = __webpack_require__(0);
var core_1 = __webpack_require__(1);
var common_1 = __webpack_require__(10);
var NgxGoogleMapModule = /** @class */ (function () {
    function NgxGoogleMapModule() {
    }
    NgxGoogleMapModule = __decorate([
        core_1.NgModule({
            declarations: [ngx_google_maps_component_1.NgxGoogleMapComponent],
            imports: [common_1.CommonModule],
            exports: [ngx_google_maps_component_1.NgxGoogleMapComponent],
            providers: [],
            bootstrap: []
        })
    ], NgxGoogleMapModule);
    return NgxGoogleMapModule;
}());
exports.NgxGoogleMapModule = NgxGoogleMapModule;


/***/ }),
/* 10 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_10__;

/***/ })
/******/ ]);
});
//# sourceMappingURL=index.umd.js.map